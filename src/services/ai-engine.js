import { callOpenRouterAPI } from '../openRouterApi.js';
import { ARCANUM_META_PROMPT, ARCANUM_LEVEL_PROMPTS } from './arcanum-prompts.js';
import i18n from '../i18n.js';

/**
 * ARCƒÄNUM AI Engine - G≈Ç√≥wny silnik AI dla zaawansowanych analiz psychometrycznych
 * Wykorzystuje OpenRouter API z mo≈ºliwo≈õciƒÖ wyboru r√≥≈ºnych modeli
 * Zintegrowany z oryginalnƒÖ strukturƒÖ danych z tabeli Persons
 */
class AIEngine {
  constructor() {
    // Dostƒôpne modele AI
    this.availableModels = [
      {
        id: 'google/gemini-2.5-flash',
        name: 'Gemini Flash',
        description: 'Szybki model Google, idealny do szybkich analiz',
        icon: '‚ö°',
        recommended: true
      },
      {
        id: 'anthropic/claude-sonnet-4',
        name: 'Claude Sonnet 4',
        description: 'Najnowszy model Claude z najlepszƒÖ jako≈õciƒÖ analiz',
        icon: 'üß†',
        recommended: false
      },
      {
        id: 'google/gemini-pro',
        name: 'Gemini Pro',
        description: 'Zaawansowany model Google z doskona≈ÇƒÖ analizƒÖ',
        icon: 'üíé',
        recommended: false
      },
      {
        id: 'deepseek/deepseek-chat-v3-0324',
        name: 'DeepSeek Chat V3',
        description: 'Zaawansowany model z g≈ÇƒôbokƒÖ analizƒÖ psychometrycznƒÖ',
        icon: 'üîç',
        recommended: false
      },
      {
        id: 'moonshotai/kimi-k2',
        name: 'Kimi K2',
        description: 'Model od Moonshot AI',
        icon: 'üöÄ',
        recommended: false
      },
      {
        id: 'z-ai/glm-4.5',
        name: 'GLM 4.5',
        description: 'Model od Z-AI',
        icon: 'ü§ñ',
        recommended: false
      },
      {
        id: 'baidu/ernie-4.5-21b-a3b',
        name: 'Ernie 4.5',
        description: 'Model od Baidu',
        icon: 'üêæ',
        recommended: false
      }
    ];

    // Domy≈õlny model (pierwszy z listy)
    this.currentModel = this.availableModels[0].id;
    this.clientData = null;
    this.sessionId = null;
    
    console.log('‚úÖ AI Engine initialized with OpenRouter');
  }

  /**
   * Ustaw aktywny model AI
   * @param {string} modelId - ID modelu do ustawienia
   */
  setModel(modelId) {
    const model = this.availableModels.find(m => m.id === modelId);
    if (model) {
      this.currentModel = modelId;
      console.log(`üîÑ AI Model changed to: ${model.name}`);
      
      // Wyczy≈õƒá sesjƒô przy zmianie modelu
      this.clientData = null;
      this.sessionId = null;
      
      return true;
    } else {
      console.error(`‚ùå Model ${modelId} not found`);
      return false;
    }
  }

  /**
   * Pobierz aktualny model
   */
  getCurrentModel() {
    return this.availableModels.find(m => m.id === this.currentModel);
  }

  /**
   * Pobierz listƒô dostƒôpnych modeli
   */
  getAvailableModels() {
    return this.availableModels;
  }

  /**
   * Prze≈ÇƒÖcz model AI (alias dla setModel)
   * @param {string} modelId - ID nowego modelu
   */
  async switchModel(modelId) {
    return this.setModel(modelId);
  }

  /**
   * Inicjalizuje sesjƒô AI z danymi klienta (oryginalna struktura z tabeli Persons)
   * @param {Object} clientData - Dane klienta z oryginalnej tabeli Persons
   */
  async initializeSession(clientData) {
    try {
      this.clientData = clientData;
      this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      console.log('ü§ñ AI Engine session initialized:', this.sessionId);
      console.log('üìä Client data loaded:', {
        name: clientData.name,
        code: clientData.code,
        personalityType: clientData.personality_type,
        hasCompleteFactors: !!clientData.complete_factors
      });
      
      return true;
    } catch (error) {
      console.error('‚ùå Failed to initialize AI session:', error);
      throw error;
    }
  }

  /**
   * Generuje analizƒô dla okre≈õlonego poziomu
   * @param {number} levelNumber - Numer poziomu (1-5)
   * @returns {Promise<Object>} Wynik analizy
   */
  async generateLevel(levelNumber) {
    if (!this.clientData) {
      throw new Error('Session not initialized. Call initializeSession first.');
    }

    if (levelNumber < 1 || levelNumber > 5) {
      throw new Error('Invalid level number. Must be between 1 and 5.');
    }

    try {
      console.log(`üß† Generating ARCƒÄNUM Level ${levelNumber} analysis...`);

      // Pobierz prompt dla danego poziomu
      const levelPrompt = ARCANUM_LEVEL_PROMPTS(i18n.language)[levelNumber];
      if (!levelPrompt) {
        throw new Error(`No prompt found for level ${levelNumber}`);
      }

      // Przygotuj pe≈Çny prompt z danymi klienta
      const fullPrompt = this.preparePromptWithClientData(levelPrompt, levelNumber);

      // Wywo≈Çaj OpenRouter API
      const response = await callOpenRouterAPI(
        fullPrompt,
        this.currentModel,
        ARCANUM_META_PROMPT,
        {
          sessionId: this.sessionId,
          mode: `level-${levelNumber}`,
          timestamp: new Date().toISOString()
        }
      );

      // Parsuj odpowied≈∫ w zale≈ºno≈õci od poziomu
      const parsedContent = this.parseResponse(levelNumber, response);

      console.log(`‚úÖ Level ${levelNumber} analysis completed`);
      return {
        success: true,
        level: levelNumber,
        content: parsedContent,
        rawText: response,
        timestamp: new Date().toISOString(),
        model: this.getCurrentModel().name
      };

    } catch (error) {
      console.error(`‚ùå Failed to generate Level ${levelNumber}:`, error);
      throw new Error(`Level ${levelNumber} generation failed: ${error.message}`);
    }
  }

  /**
   * Generuje odpowied≈∫ na podstawie dowolnego promptu i kontekstu
   * @param {string} prompt - Tre≈õƒá promptu do wykonania
   * @param {string} context - Kontekst (np. MetaAnalysis)
   * @param {'html' | 'json'} format - Oczekiwany format odpowiedzi
   * @returns {Promise<string|Object>} Wynik analizy w zadanym formacie
   */
  async generateGenericPrompt(prompt, context, format = 'html') {
    if (!this.clientData) {
      throw new Error('Session not initialized. Call initializeSession first.');
    }

    try {
      console.log(`üß† Generating response for generic prompt (format: ${format})...`);

      const fullPrompt = `
        KONTEKST (WSTƒòPNA ANALIZA):
        ${context}

        POLECENIE:
        ${prompt}
      `;

      const response = await callOpenRouterAPI(
        fullPrompt,
        this.currentModel,
        ARCANUM_META_PROMPT, // Meta-prompt systemowy nadal jest u≈ºywany
        {
          sessionId: this.sessionId,
          mode: 'generic-prompt',
          timestamp: new Date().toISOString()
        }
      );

      if (format === 'json') {
        try {
          // Pr√≥ba sparsowania JSON-a z potencjalnych markdown code blocks
          const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/);
          return JSON.parse(jsonMatch ? jsonMatch[1] : response);
        } catch (e) {
          console.error("B≈ÇƒÖd parsowania JSON, zwracam surowy tekst:", e);
          return { error: "Invalid JSON response", raw: response };
        }
      }

      console.log(`‚úÖ Generic prompt response generated successfully`);
      return response; // Dla HTML zwracamy surowy tekst

    } catch (error) {
      console.error(`‚ùå Failed to generate response for generic prompt:`, error);
      throw new Error(`Generic prompt generation failed: ${error.message}`);
    }
  }

  /**
   * Przygotowuje prompt z danymi klienta
   * @param {string} levelPrompt - String promptu dla poziomu
   * @returns {string} Pe≈Çny prompt z danymi klienta
   */
  preparePromptWithClientData(levelPrompt) {
    // Przekszta≈Çƒá dane klienta do formatu JSON dla promptu
    const clientDataJson = JSON.stringify({
      profileId: this.clientData.code,
      timestamp: new Date().toISOString(),
      clientInfo: {
        name: this.clientData.name || 'Anonymous',
        email: this.clientData.email || '',
        testDate: this.clientData.date || new Date().toISOString()
      },
      // Mapowanie oryginalnych p√≥l na format oczekiwany przez AI
      personalityData: {
        personality_type: this.clientData.personality_type || '',
        complete_factors: this.clientData.complete_factors || '',
        interests: this.clientData.interests || '',
        skills: this.clientData.skills || '',
        education: this.clientData.education || '',
        education_field: this.clientData.education_field || '',
        career_stage: this.clientData.career_stage || '',
        sector: this.clientData.sector || '',
        current_job: this.clientData.current_job || '',
        target_job: this.clientData.target_job || '',
        personality_traits: this.clientData.personality_traits || '',
        strengths: this.clientData.strengths || '',
        communication_style: this.clientData.communication_style || '',
        work_environment_features: this.clientData.work_environment_features || '',
        career_by_skills: this.clientData.career_by_skills || '',
        career_for_type: this.clientData.career_for_type || '',
        work_style: this.clientData.work_style || '',
        physical_effort: this.clientData.physical_effort || '',
        digital_skills: this.clientData.digital_skills || '',
        values: this.clientData.values || ''
      },
      metadata: {
        testVersion: '1.0',
        language: 'pl',
        completionRate: 100,
        validityScore: 95,
        pro: this.clientData.pro || false,
        paid: this.clientData.paid || false,
        advanced: this.clientData.advanced || false
      }
    }, null, 2);

    // Po≈ÇƒÖcz prompt z danymi klienta
    return `${levelPrompt}

DANE KLIENTA DO ANALIZY:
${clientDataJson}

Na podstawie powy≈ºszych danych wygeneruj analizƒô zgodnie z formatem okre≈õlonym w poleceniu.`;
  }

  /**
   * Parsowanie odpowiedzi AI w zale≈ºno≈õci od poziomu
   * @param {number} level - Poziom analizy
   * @param {string} text - Surowa odpowied≈∫ z AI
   * @returns {Object} Sparsowana tre≈õƒá
   */
  parseResponse(level, text) {
    try {
      switch (level) {
        case 1: // Hero Dashboard
          return this.parseLevel1(text);
        case 2: // Strategiczne Wymiary
          return this.parseLevel2(text);
        case 3: // Zaawansowane Analizy
          return this.parseLevel3(text);
        case 4: // Ukryte Skarby
          return this.parseLevel4(text);
        case 5: // Kompas Akademicki
          return this.parseLevel5(text);
        default:
          return { rawText: text };
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to parse Level ${level} response, returning raw text:`, error);
      return { rawText: text };
    }
  }

  /**
   * Parsowanie Poziomu 1 - Hero Dashboard
   */
  parseLevel1(text) {
    const sections = this.extractSections(text);
    
    return {
      dominantArchetype: this.extractValue(text, /DominujƒÖcy Archetyp Zawodowy[:\s]*(.+?)(?:\n|$)/i) || 
                        this.extractValue(text, /Archetyp[:\s]*(.+?)(?:\n|$)/i) ||
                        'Strategiczny Lider',
      leadershipIndex: this.extractLeadershipIndex(text),
      psychometricProfile: this.extractPsychometricProfile(text),
      strategicHighlights: this.extractStrategicHighlights(text),
      sections
    };
  }

  /**
   * Parsowanie Poziomu 2 - Strategiczne Wymiary
   */
  parseLevel2(text) {
    return {
      profilPsychometryczny: this.extractSection(text, 'Profil Psychometryczny'),
      potencjalPrzywodczy: this.extractSection(text, 'Potencja≈Ç Przyw√≥dczy'),
      dopasowanieOrganizacyjne: this.extractSection(text, 'Dopasowanie Organizacyjne'),
      prognozaRozwoju: this.extractSection(text, 'Prognoza Rozwoju')
    };
  }

  /**
   * Parsowanie Poziomu 3 - Zaawansowane Analizy
   */
  parseLevel3(text) {
    return {
      profilPsychometryczny: {
        analizaMotywacji: this.extractSubsection(text, 'Analiza motywacji wewnƒôtrznych'),
        wzorcePodejmowaniaDecyzji: this.extractSubsection(text, 'Wzorce podejmowania decyzji'),
        styleKomunikacji: this.extractSubsection(text, 'Style komunikacji w stresie'),
        predyspozycjeInnowacji: this.extractSubsection(text, 'Predyspozycje do innowacji')
      },
      potencjalPrzywodczy: {
        analizaWplywu: this.extractSubsection(text, 'Analiza wp≈Çywu na zespo≈Çy'),
        skutecznoscBranze: this.extractSubsection(text, 'Skuteczno≈õƒá w r√≥≈ºnych bran≈ºach'),
        potencjalTransformacyjny: this.extractSubsection(text, 'Potencja≈Ç transformacyjny'),
        ryzykoWypalenia: this.extractSubsection(text, 'Ryzyko wypalenia zawodowego')
      },
      dopasowanieOrganizacyjne: {
        kompatybilnoscKultur: this.extractSubsection(text, 'Kompatybilno≈õƒá z typami kultur korporacyjnych'),
        optymalnaWielkoscZespolu: this.extractSubsection(text, 'Optymalna wielko≈õƒá zespo≈Çu'),
        preferowaneStruktury: this.extractSubsection(text, 'Preferowane struktury hierarchiczne'),
        efektywnoscZdalnej: this.extractSubsection(text, 'Efektywno≈õƒá w pracy zdalnej/hybrydowej')
      },
      prognozaRozwoju: {
        analizaLuk: this.extractSubsection(text, 'Analiza luk kompetencyjnych'),
        rekomendacjeRozwojowe: this.extractSubsection(text, 'Rekomendacje rozwojowe'),
        potencjalneSciezki: this.extractSubsection(text, 'Potencjalne ≈õcie≈ºki kariery'),
        wskaznikiSukcesu: this.extractSubsection(text, 'Wska≈∫niki sukcesu d≈Çugoterminowego')
      }
    };
  }

  /**
   * Parsowanie Poziomu 4 - Ukryte Skarby
   */
  parseLevel4(text) {
    return {
      analizaPredykcyjnaStresu: this.extractSection(text, 'Analiza Predykcyjna Stresu'),
      indeksKreatywnosciStrategicznej: this.extractSection(text, 'Indeks Kreatywno≈õci Strategicznej'),
      mapaWplywuSpolecznego: this.extractSection(text, 'Mapa Wp≈Çywu Spo≈Çecznego'),
      profilEnergiiZawodowej: this.extractSection(text, 'Profil Energii Zawodowej'),
      analizaPodejmowaniaDecyzji: this.extractSection(text, 'Analiza Podejmowania Decyzji'),
      kompatybilnoscKulturowa: this.extractSection(text, 'Kompatybilno≈õƒá Kulturowa'),
      indeksAdaptacyjnosci: this.extractSection(text, 'Indeks Adaptacyjno≈õci')
    };
  }

  /**
   * Parsowanie Poziomu 5 - Kompas Akademicki
   */
  parseLevel5(text) {
    return {
      profilUczeniaSie: this.extractSection(text, 'Profil Uczenia Siƒô'),
      indeksPotencjaluAdaptacyjnego: this.extractSection(text, 'Indeks Potencja≈Çu Adaptacyjnego'),
      rekomendowaneRoleStartowe: this.extractSection(text, 'Rekomendowane Role Startowe'),
      mapaKompetencjiRozwoju: this.extractSection(text, 'Mapa Kompetencji do Rozwoju'),
      strategiaBudowaniaMarki: this.extractSection(text, 'Strategia Budowania Marki Osobistej')
    };
  }

  // Utility methods for parsing

  /**
   * WyciƒÖgnij warto≈õƒá wska≈∫nika przyw√≥dztwa
   */
  extractLeadershipIndex(text) {
    const match = text.match(/(\d+)\/100/) || text.match(/(\d+)%/) || text.match(/(\d+)\s*punkt√≥w/);
    return match ? parseInt(match[1]) : 75; // fallback
  }

  /**
   * WyciƒÖgnij profil psychometryczny 360¬∞
   */
  extractPsychometricProfile(text) {
    const profileSection = this.extractSection(text, 'Psychometryczny Profil 360¬∞') ||
                          this.extractSection(text, 'Profil 360¬∞');
    if (!profileSection) return [];

    // Parsuj listƒô wypunktowanƒÖ
    const items = profileSection.split('\n')
      .filter(line => line.trim().startsWith('-') || line.trim().startsWith('‚Ä¢') || line.trim().startsWith('*'))
      .map(line => {
        const cleaned = line.replace(/^[-‚Ä¢*]\s*/, '').trim();
        const parts = cleaned.split(':');
        return {
          label: parts[0]?.trim() || '',
          value: parts[1]?.trim() || parts[0]?.trim() || ''
        };
      })
      .filter(item => item.label);

    return items.length > 0 ? items : [
      { label: 'Styl Przyw√≥dztwa', value: 'Strategiczny' },
      { label: 'Motywatory G≈Ç√≥wne', value: 'OsiƒÖgniƒôcia i rozw√≥j' },
      { label: 'Obszar Rozwoju', value: 'Komunikacja w zespole' },
      { label: 'Fit Organizacyjny', value: '≈örodowiska dynamiczne' }
    ];
  }

  /**
   * WyciƒÖgnij Strategic Highlights
   */
  extractStrategicHighlights(text) {
    const highlightsSection = this.extractSection(text, 'Strategic Highlights') ||
                             this.extractSection(text, 'Kluczowe Insights');
    if (!highlightsSection) return [];

    const highlights = highlightsSection.split('\n')
      .filter(line => line.trim().startsWith('-') || line.trim().startsWith('‚Ä¢') || line.trim().startsWith('*'))
      .map(line => line.replace(/^[-‚Ä¢*]\s*/, '').trim())
      .filter(item => item.length > 0);

    return highlights.length > 0 ? highlights : [
      'Wysokie predyspozycje do przyw√≥dztwa strategicznego',
      'Naturalna zdolno≈õƒá do budowania zespo≈Ç√≥w',
      'Efektywno≈õƒá w ≈õrodowiskach o wysokiej dynamice',
      'Potencja≈Ç do transformacji organizacyjnej'
    ];
  }

  /**
   * WyciƒÖgnij sekcjƒô z tekstu
   */
  extractSection(text, sectionName) {
    const patterns = [
      new RegExp(`${sectionName}[:s]*\n([\\s\\S]*?)(?=\n[A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª]|$)`, 'i'),
      new RegExp(`##\\s*${sectionName}([\\s\\S]*?)(?=\n##|$)`, 'i'),
      new RegExp(`\\*\\*${sectionName}\\*\\*([\\s\\S]*?)(?=\n\\*\\*|$)`, 'i')
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) return match[1].trim();
    }

    return '';
  }

  /**
   * WyciƒÖgnij podsekcjƒô z tekstu
   */
  extractSubsection(text, subsectionName) {
    const patterns = [
      new RegExp(`${subsectionName}[:s]*\n([\\s\\S]*?)(?=\n[A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª]|$)`, 'i'),
      new RegExp(`###\\s*${subsectionName}([\\s\\S]*?)(?=\n###|$)`, 'i')
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) return match[1].trim();
    }

    return '';
  }

  /**
   * WyciƒÖgnij warto≈õƒá z tekstu u≈ºywajƒÖc regex
   */
  extractValue(text, regex) {
    const match = text.match(regex);
    return match ? match[1].trim() : '';
  }

  /**
   * WyciƒÖgnij wszystkie sekcje z tekstu
   */
  extractSections(text) {
    const sections = {};
    const lines = text.split('\n');
    let currentSection = null;
    let currentContent = [];

    for (const line of lines) {
      if (line.match(/^#+\s+/) || line.match(/^\*\*[^*]+\*\*$/)) {
        // Zapisz poprzedniƒÖ sekcjƒô
        if (currentSection) {
          sections[currentSection] = currentContent.join('\n').trim();
        }
        // Rozpocznij nowƒÖ sekcjƒô
        currentSection = line.replace(/^#+\s+|\*\*/g, '').trim();
        currentContent = [];
      } else if (currentSection) {
        currentContent.push(line);
      }
    }

    // Zapisz ostatniƒÖ sekcjƒô
    if (currentSection) {
      sections[currentSection] = currentContent.join('\n').trim();
    }

    return sections;
  }

  /**
   * Sprawd≈∫ status sesji
   */
  getSessionStatus() {
    return {
      initialized: !!this.clientData,
      sessionId: this.sessionId,
      clientName: this.clientData?.name || null,
      clientCode: this.clientData?.code || null,
      model: this.getCurrentModel()
    };
  }

  /**
   * Wyczy≈õƒá sesjƒô
   */
  clearSession() {
    this.clientData = null;
    this.sessionId = null;
    console.log('üßπ AI Engine session cleared');
  }
}

// Eksport instancji silnika
export const aiEngine = new AIEngine();
